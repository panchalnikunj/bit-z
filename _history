{"entries":[{"timestamp":1742021778060,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"//% color=#000000 icon=\"\\uf2db\" block=\"Bit-Z\"\nnamespace dCode {\n    //% group=\"Car Control\"\n    //% blockId=car_control block=\"Move car %direction speed %speed\"\n    //% speed.min=0 speed.max=100\n    export function carMove(direction: CarDirection, speed: number): void {\n        let pwmValue = Math.map(speed, 0, 100, 0, 1023);\n\n        switch (direction) {\n            case CarDirection.Forward:\n                pins.analogWritePin(AnalogPin.P12, pwmValue);\n                pins.analogWritePin(AnalogPin.P13, 0);\n                pins.analogWritePin(AnalogPin.P14, 0);\n                pins.analogWritePin(AnalogPin.P15, pwmValue);\n                break;\n            case CarDirection.Backward:\n                pins.analogWritePin(AnalogPin.P12, 0);\n                pins.analogWritePin(AnalogPin.P13, pwmValue);\n                pins.analogWritePin(AnalogPin.P14, pwmValue);\n                pins.analogWritePin(AnalogPin.P15, 0);\n                break;\n            case CarDirection.Left:\n                pins.analogWritePin(AnalogPin.P12, 0);\n                pins.analogWritePin(AnalogPin.P13, pwmValue);\n                pins.analogWritePin(AnalogPin.P14, 0);\n                pins.analogWritePin(AnalogPin.P15, pwmValue);\n                break;\n            case CarDirection.Right:\n                pins.analogWritePin(AnalogPin.P12, pwmValue);\n                pins.analogWritePin(AnalogPin.P13, 0);\n                pins.analogWritePin(AnalogPin.P14, pwmValue);\n                pins.analogWritePin(AnalogPin.P15, 0);\n                break;\n            case CarDirection.Stop:\n                pins.analogWritePin(AnalogPin.P12, 0);\n                pins.analogWritePin(AnalogPin.P13, 0);\n                pins.analogWritePin(AnalogPin.P14, 0);\n                pins.analogWritePin(AnalogPin.P15, 0);\n                break;\n        }\n    }\n\n    //% blockId=car_direction block=\"%direction\"\n    //% blockHidden=true\n    export enum CarDirection {\n        //% block=\"Forward\"\n        Forward = 0,\n        //% block=\"Backward\"\n        Backward = 1,\n        //% block=\"Left\"\n        Left = 2,\n        //% block=\"Right\"\n        Right = 3,\n        //% block=\"Stop\"\n        Stop = 4\n    }\n\n\n    //% group=\"LCD\"\n    let i2cAddr: number // 0x3F: PCF8574A, 0x27: PCF8574\n    let BK: number      // backlight control\n    let RS: number      // command/data\n\n    // set LCD reg\n    function setreg(d: number) {\n        pins.i2cWriteNumber(i2cAddr, d, NumberFormat.Int8LE)\n        basic.pause(1)\n    }\n\n    // send data to I2C bus\n    function set(d: number) {\n        d = d & 0xF0\n        d = d + BK + RS\n        setreg(d)\n        setreg(d + 4)\n        setreg(d)\n    }\n\n    // send command\n    function cmd(d: number) {\n        RS = 0\n        set(d)\n        set(d << 4)\n    }\n\n    // send data\n    function dat(d: number) {\n        RS = 1\n        set(d)\n        set(d << 4)\n    }\n\n    // auto get LCD address\n    function AutoAddr() {\n        let k = true\n        let addr = 0x20\n        let d1 = 0, d2 = 0\n        while (k && (addr < 0x28)) {\n            pins.i2cWriteNumber(addr, -1, NumberFormat.Int32LE)\n            d1 = pins.i2cReadNumber(addr, NumberFormat.Int8LE) % 16\n            pins.i2cWriteNumber(addr, 0, NumberFormat.Int16LE)\n            d2 = pins.i2cReadNumber(addr, NumberFormat.Int8LE)\n            if ((d1 == 7) && (d2 == 0)) k = false\n            else addr += 1\n        }\n        if (!k) return addr\n\n        addr = 0x38\n        while (k && (addr < 0x40)) {\n            pins.i2cWriteNumber(addr, -1, NumberFormat.Int32LE)\n            d1 = pins.i2cReadNumber(addr, NumberFormat.Int8LE) % 16\n            pins.i2cWriteNumber(addr, 0, NumberFormat.Int16LE)\n            d2 = pins.i2cReadNumber(addr, NumberFormat.Int8LE)\n            if ((d1 == 7) && (d2 == 0)) k = false\n            else addr += 1\n        }\n        if (!k) return addr\n        else return 0\n\n    }\n\n\n    //% group=\"LCD\"\n    /**\n     * initial LCD, set I2C address. Address is 39/63 for PCF8574/PCF8574A\n     * @param Addr is i2c address for LCD, eg: 0, 39, 63. 0 is auto find address\n     */\n    //% blockId=\"I2C_LCD1620_SET_ADDRESS\" block=\"LCD initialize %addr\"\n    //% weight=100 blockGap=8\n    //% parts=LCD1602_I2C trackArgs=0\n    export function LcdInit(Addr: number) {\n        if (Addr == 0) i2cAddr = AutoAddr()\n        else i2cAddr = Addr\n        BK = 8\n        RS = 0\n        cmd(0x33)       // set 4bit mode\n        basic.pause(5)\n        set(0x30)\n        basic.pause(5)\n        set(0x20)\n        basic.pause(5)\n        cmd(0x28)       // set mode\n        cmd(0x0C)\n        cmd(0x06)\n        cmd(0x01)       // clear\n    }\n\n    //% group=\"LCD\"\n    /**\n     * show a number in LCD at given position\n     * @param n is number will be show, eg: 0, 100, 200\n     * @param x is LCD column position, eg: 0\n     * @param y is LCD row position, eg: 0\n     */\n    //% blockId=\"I2C_LCD1620_SHOW_NUMBER\" block=\"show number %n|at x %x|y %y\"\n    //% weight=90 blockGap=8\n    //% x.min=0 x.max=15\n    //% y.min=0 y.max=1\n    //% parts=LCD1602_I2C trackArgs=0\n    export function ShowNumber(n: number, x: number, y: number): void {\n        let s = n.toString()\n        ShowString(s, x, y)\n    }\n\n    //% group=\"LCD\"\n    /**\n     * show a string in LCD at given position\n     * @param s is string will be show, eg: \"Hello!\"\n     * @param x is LCD column position, [0 - 15], eg: 0\n     * @param y is LCD row position, [0 - 1], eg: 0\n     */\n    //% blockId=\"I2C_LCD1620_SHOW_STRING\" block=\"show string %s|at x %x|y %y\"\n    //% weight=90 blockGap=8\n    //% x.min=0 x.max=15\n    //% y.min=0 y.max=1\n    //% parts=LCD1602_I2C trackArgs=0\n    export function ShowString(s: string, x: number, y: number): void {\n        let a: number\n\n        if (y > 0)\n            a = 0xC0\n        else\n            a = 0x80\n        a += x\n        cmd(a)\n\n        for (let i = 0; i < s.length; i++) {\n            dat(s.charCodeAt(i))\n        }\n    }\n\n    //% group=\"LCD\"\n    /**\n     * turn on LCD\n     */\n    //% blockId=\"I2C_LCD1620_ON\" block=\"turn on LCD\"\n    //% weight=81 blockGap=8\n    //% parts=LCD1602_I2C trackArgs=0\n    export function on(): void {\n        cmd(0x0C)\n    }\n\n    //% group=\"LCD\"\n    /**\n     * turn off LCD\n     */\n    //% blockId=\"I2C_LCD1620_OFF\" block=\"turn off LCD\"\n    //% weight=80 blockGap=8\n    //% parts=LCD1602_I2C trackArgs=0\n    export function off(): void {\n        cmd(0x08)\n    }\n\n    //% group=\"LCD\"\n    /**\n     * clear all display content\n     */\n    //% blockId=\"I2C_LCD1620_CLEAR\" block=\"clear LCD\"\n    //% weight=85 blockGap=8\n    //% parts=LCD1602_I2C trackArgs=0\n    export function clear(): void {\n        cmd(0x01)\n    }\n\n    //% group=\"LCD\"\n    /**\n     * turn on LCD backlight\n     */\n    //% blockId=\"I2C_LCD1620_BACKLIGHT_ON\" block=\"turn on backlight\"\n    //% weight=71 blockGap=8\n    //% parts=LCD1602_I2C trackArgs=0\n    export function BacklightOn(): void {\n        BK = 8\n        cmd(0)\n    }\n    //% group=\"LCD\"\n\n    /**\n     * turn off LCD backlight\n     */\n    //% blockId=\"I2C_LCD1620_BACKLIGHT_OFF\" block=\"turn off backlight\"\n    //% weight=70 blockGap=8\n    //% parts=LCD1602_I2C trackArgs=0\n    export function BacklightOff(): void {\n        BK = 0\n        cmd(0)\n    }\n\n    //% group=\"LCD\"\n    /**\n     * shift left\n     */\n    //% blockId=\"I2C_LCD1620_SHL\" block=\"Shift Left\"\n    //% weight=61 blockGap=8\n    //% parts=LCD1602_I2C trackArgs=0\n    export function shl(): void {\n        cmd(0x18)\n    }\n\n    //% group=\"LCD\"\n    /**\n     * shift right\n     */\n    //% blockId=\"I2C_LCD1620_SHR\" block=\"Shift Right\"\n    //% weight=60 blockGap=8\n    //% parts=LCD1602_I2C trackArgs=0\n    export function shr(): void {\n        cmd(0x1C)\n    }\n\n\n    //% group=\"Actuators\"\n    //% blockId=servo_motor block=\"set servo %servo to %angle°\"\n    //% angle.min=0 angle.max=180\n    //% servo.defl=Servo.S1\n    export function setServoAngle(servo: Servo, angle: number): void {\n        let pin = (servo == Servo.S1) ? AnalogPin.P6 : AnalogPin.P7;\n        let pulseWidth = (angle * 2000) / 180 + 500; // Convert angle (0-180) to pulse width (500-2500µs)\n        pins.servoSetPulse(pin, pulseWidth);\n    }\n\n    //% blockId=servo_enum block=\"%servo\"\n    //% blockHidden=true\n    export enum Servo {\n        //% block=\"S1\"\n        S1 = 0,\n        //% block=\"S2\"\n        S2 = 1\n    }\n\n\n\n    //% group=\"Sensors\"\n    //% blockId=dht11_sensor block=\"read DHT11 %dhtData at pin %pin\"\n    //% pin.defl=DigitalPin.P2\n    export function readDHT11(dhtData: DHT11Data, pin: DigitalPin): number {\n        let buffer: number[] = [];\n        let startTime: number;\n        let signal: number;\n\n        // Start signal\n        pins.digitalWritePin(pin, 0);\n        basic.pause(18);\n        pins.digitalWritePin(pin, 1);\n        control.waitMicros(40);\n        pins.setPull(pin, PinPullMode.PullUp);\n\n        // Wait for response\n        while (pins.digitalReadPin(pin) == 1);\n        while (pins.digitalReadPin(pin) == 0);\n        while (pins.digitalReadPin(pin) == 1);\n\n        // Read 40-bit data (5 bytes)\n        for (let i = 0; i < 40; i++) {\n            while (pins.digitalReadPin(pin) == 0);\n            startTime = control.micros();\n            while (pins.digitalReadPin(pin) == 1);\n            signal = control.micros() - startTime;\n            buffer.push(signal > 40 ? 1 : 0);\n        }\n\n        // Convert data\n        let humidity = (buffer.slice(0, 8).reduce((a, b) => (a << 1) | b, 0));\n        let temperature = (buffer.slice(16, 24).reduce((a, b) => (a << 1) | b, 0));\n\n        return dhtData == DHT11Data.Temperature ? temperature : humidity;\n    }\n\n    //% blockId=dht11_data block=\"%dhtData\"\n    //% blockHidden=true\n    export enum DHT11Data {\n        //% block=\"Temperature (°C)\"\n        Temperature = 0,\n        //% block=\"Humidity (%)\"\n        Humidity = 1\n    }\n\n\n    //% group=\"Sensors\"\n    /**\n     * Measures distance in centimeters using an HC-SR04 sensor.\n     * @param trigPin The trigger pin\n     * @param echoPin The echo pin\n     */\n    //% blockId=ultrasonic_distance block=\"measure distance trig %trigPin| echo %echoPin\"\n    //% trigPin.defl=DigitalPin.P0 echoPin.defl=DigitalPin.P1\n    export function measureDistance(trigPin: DigitalPin, echoPin: DigitalPin): number {\n        pins.digitalWritePin(trigPin, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(trigPin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(trigPin, 0);\n\n        let duration = pins.pulseIn(echoPin, PulseValue.High, 23000);\n        let distance = duration / 58;\n\n        return distance > 400 ? 400 : distance; // Limit to 400 cm (sensor range)\n    }\n\n    //% group=\"Sensors\"\n    //% blockId=analog_sensor block=\"read Analog sensor at pin %pin\"\n    //% pin.defl=AnalogPin.P0\n    export function readAnalogSensor(pin: AnalogPin): number {\n        return pins.analogReadPin(pin);\n    }\n\n\n    //% group=\"Sensors\"\n    //% blockId=digital_sensor block=\"read Digital sensor at pin %pin\"\n    //% pin.defl=DigitalPin.P1\n    export function readDigitalSensor(pin: DigitalPin): number {\n        return pins.digitalReadPin(pin);\n    }\n\n\n}"],[1,"\n"]],"start1":0,"start2":0,"length1":11037,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"  \"main."],[-1,"t"],[1,"block"],[0,"s\",\n    "]],"start1":165,"start2":165,"length1":17,"length2":21},{"diffs":[[0,"   \""],[-1,"README.md\"\n    ],\n    \"testFiles\": ["],[1,"main.ts\","],[0,"\n   "]],"start1":187,"start2":187,"length1":44,"length2":17},{"diffs":[[0,"   \""],[-1,"test.ts"],[1,"README.md"],[0,"\"\n  "]],"start1":206,"start2":206,"length1":15,"length2":17},{"diffs":[[0,"   \""],[-1,"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":229,"start2":229,"length1":32,"length2":31}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1742021778059,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Bit-z\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1742022268526}